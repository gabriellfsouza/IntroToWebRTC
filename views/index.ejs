<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>O'Reilly Introduction to WebRTC</title>
    <link rel="stylesheet" type="text/css" href="styles.css" />
    <script src="/socket.io/socket.io.js"></script>
  </head>
  <body>
    <video id="myVideoTag" autoplay></video>
    <video id="theirVideoTag" autoplay></video>
    <div>
      <label>Your name</label><input id="myName" type="text" />
      <label>Message</label><input id="myMessage" type="text" />
      <input id="sendMessage" type="submit" />
      <div id="chatArea">Message Output:<br /></div>
      <div id="signalingArea">Signaling Messages: <br /></div>
    </div>

    <script>
      const myVideoArea = document.querySelector("#myVideoTag");
      const theirVideoArea = document.querySelector("#theirVideoTag");
      const myName = document.querySelector("#myName");
      const myMessage = document.querySelector("#myMessage");
      const sendMessage = document.querySelector("#sendMessage");
      const chatArea = document.querySelector("#chatArea");
      const signalingArea = document.querySelector("#signalingArea");
      const ROOM = "chat";
      const SIGNAL_ROOM = "signal_room";
      const configuration = {
        iceServers: [
          {
            url: "stun:stun.l.google.19302"
          }
        ]
      };
      let rtcPeerConn;

      socket = io();
      socket.emit("ready", {
        chat_room: ROOM,
        signal_room: SIGNAL_ROOM
      });

      // Send a first signaling message to anyone listening
      // This normally would be on a button click
      socket.emit("signal", {
        type: "user_here",
        message: "Are you ready for a call?",
        room: SIGNAL_ROOM
      });

      socket.on("signaling_message", data => {
        displaySignalMessage("Signal received: " + data.type);

        //Setup the RTC Peer Connection object
        if (!rtcPeerConn) startSignaling();

        if (data.type !== "user_here") {
          const message = JSON.parse(data.message);
          if (message.sdp) {
            rtcPeerConn.setRemoteDescription(
              new RTCSessionDescription(message.sdp),
              () => {
                //if we received an offer, we need to answer
                if (rtcPeerConn.remoteDescription.type === "offer")
                  rtcPeerConn.createAnswer(sendLocalDesc, logError);
              },
              logError
            );
          } else {
            rtcPeerConn.addIceCandidate(new RTCIceCandidate(message.candidate));
          }
        }
      });

      function startSignaling() {
        displaySignalMessage("starting signaling...");

        rtcPeerConn = new RTCPeerConnection(configuration);

        // send any ice candidates to the other peer
        rtcPeerConn.onicecandidate = evt => {
          if (evt.candidate)
            io.emit("signal", {
              type: "icecandidate",
              message: JSON.stringify({
                candidate: evt.candidate
              })
            });
          displaySignalMessage("completed that ice candidate...");
        };

        // let the 'negotiationneeded' event trigger offer generation
        rtcPeerConn.onnegotiationneeded = () => {
          displaySignalMessage("on negotiation called");
          debugger;
          rtcPeerConn.createOffer(sendLocalDesc, logError);
        };
        debugger;

        // once remote stream arrives, show it in the remote video element
        rtcPeerConn.onaddstream = evt => {
          displaySignalMessage("going to add their stream...");
          theirVideoArea.srcObject(evt.stream);
        };

        // get a local stream, show it in your video tag and add it to be sent
        navigator.getUserMedia(
          {
            audio: true,
            video: true
          },
          stream => {
            displaySignalMessage("going to display my stream...");
            myVideoArea.srcObject(stream);
            rtcPeerConn.addStream(stream);
          },
          logError
        );
      }

      function sendLocalDesc(desc) {
        debugger;
        rtcPeerConn.setLocalDescription(desc, () => {
          displayMessage("sending local description");
          debugger;
          socket.emit(
            "signal",
            {
              type: "SDP",
              message: JSON.stringify({
                sdp: rtcPeerConn.localDescription
              }),
              room: SIGNAL_ROOM
            },
            logError
          );
        });
      }

      function logError(error) {
        displaySignalMessage(error.name + ": " + error.message);
      }

      socket.on("announce", data => {
        displayMessage(data.message);
      });

      socket.on("message", data => {
        displayMessage(data.author + ": " + data.message);
      });

      sendMessage.addEventListener("click", evt => {
        socket.emit("send", {
          author: myName.value,
          message: myMessage.value,
          room: ROOM
        });
      });

      function displayMessage(message) {
        chatArea.innerHTML = chatArea.innerHTML + "<br />" + message;
      }

      function displaySignalMessage(message) {
        signalingArea.innerHTML = signalingArea.innerHTML + "<br />" + message;
      }
    </script>
  </body>
</html>
