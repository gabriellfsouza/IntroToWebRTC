<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>O'Reilly Introduction to WebRTC</title>
    <link rel="stylesheet" type="text/css" href="styles.css" />
    <script src="/socket.io/socket.io.js"></script>
  </head>
  <body>
    <video id="myVideoTag" autoplay></video>
    <video id="theirVideoTag" autoplay></video>
    <div>
      <label>Your name</label><input id="myName" type="text" />
      <label>Message</label><input id="myMessage" type="text" />
      <input id="sendMessage" type="submit" />
      <div id="chatArea">Message Output:<br /></div>
      <div id="signalingArea">Signaling Messages: <br /></div>
    </div>

    <script>
      const myVideoArea = document.querySelector("#myVideoTag");
      const theirVideoArea = document.querySelector("#theirVideoTag");
      const myName = document.querySelector("#myName");
      const myMessage = document.querySelector("#myMessage");
      const sendMessage = document.querySelector("#sendMessage");
      const chatArea = document.querySelector("#chatArea");
      const signalingArea = document.querySelector("#signalingArea");
      const ROOM = "chat";
      const SIGNAL_ROOM = "signal_room";
      const configuration = {
        iceServers: [
          {
            url: "stun:stun.l.google.19302"
          }
        ]
      };
      let rtcPeerConn;
      const dataChannelOptions = {
        ordered: false, // no guaranteed delivery, unreliable but faster
        maxRetransmitTime: 1000 //milliseconds
      };
      let dataChannel;

      socket = io();
      socket.emit("ready", {
        chat_room: ROOM,
        signal_room: SIGNAL_ROOM
      });

      // Send a first signaling message to anyone listening
      // This normally would be on a button click
      socket.emit("signal", {
        type: "user_here",
        message: "Are you ready for a call?",
        room: SIGNAL_ROOM
      });

      socket.on("signaling_message", data => {
        displaySignalMessage("Signal received: " + data.type);

        //Setup the RTC Peer Connection object
        if (!rtcPeerConn) startSignaling();

        if (data.type !== "user_here") {
          const message = JSON.parse(data.message);
          if (message.sdp) {
            rtcPeerConn.setRemoteDescription(
              new RTCSessionDescription(message.sdp),
              () => {
                //if we received an offer, we need to answer
                if (rtcPeerConn.remoteDescription.type === "offer")
                  rtcPeerConn.createAnswer(sendLocalDesc, logError);
              },
              logError
            );
          } else {
            rtcPeerConn.addIceCandidate(new RTCIceCandidate(message.candidate));
          }
        }
      });

      function startSignaling() {
        displaySignalMessage("starting signaling...");

        rtcPeerConn = new RTCPeerConnection(configuration, null);
        dataChannel = rtcPeerConn.createDataChannel(
          "textMessages",
          dataChannelOptions
        );

        dataChannel.onopen = dataChannelStateChanged;
        rtcPeerConn.ondatachannel = receiveDataChannel;

        // send any ice candidates to the other peer
        rtcPeerConn.onicecandidate = evt => {
          if (evt.candidate)
            socket.emit("signal", {
              type: "icecandidate",
              message: JSON.stringify({
                candidate: evt.candidate
              })
            });
          displaySignalMessage("completed that ice candidate...");
        };

        // let the 'negotiationneeded' event trigger offer generation
        rtcPeerConn.onnegotiationneeded = () => {
          displaySignalMessage("on negotiation called");

          rtcPeerConn.createOffer(sendLocalDesc, logError);
        };

        // once remote stream arrives, show it in the remote video element
        rtcPeerConn.onaddstream = evt => {
          displaySignalMessage("going to add their stream...");
          theirVideoArea.srcObject = evt.stream;
        };

        // get a local stream, show it in your video tag and add it to be sent
        navigator.getUserMedia =
          navigator.getUserMedia ||
          navigator.webkitGetUserMedia ||
          navigator.mozGetUserMedia;
        navigator.getUserMedia(
          {
            audio: false,
            video: {
              mandatory: {
                minWidth: 320,
                maxWidth: 320,
                minHeight: 180,
                maxHeight: 180
              }
            }
          },
          stream => {
            displaySignalMessage("going to display my stream...");
            myVideoArea.srcObject = stream;

            rtcPeerConn.addStream(stream);
          },
          logError
        );
      }

      function dataChannelStateChanged() {
        if (dataChannel.readyState === "open") {
          displaySignalMessage("Data Channel open");
          dataChannel.onmessage = receiveDataChannelMessage;
        }
      }

      function receiveDataChannel(event) {
        displaySignalMessage("Receiving a data channel");
        dataChannel = event.channel;
        dataChannel.onmessage = receiveDataChannelMessage;
      }

      function receiveDataChannelMessage(event) {
        displaySignalMessage("Incoming Message");
        displayMessage("From DataChannel: " + event.data);
      }

      function sendLocalDesc(desc) {
        rtcPeerConn.setLocalDescription(
          desc,
          () => {
            displayMessage("sending local description");

            socket.emit("signal", {
              type: "SDP",
              message: JSON.stringify({
                sdp: rtcPeerConn.localDescription
              }),
              room: SIGNAL_ROOM
            });
          },
          logError
        );
      }

      function logError(error) {
        displaySignalMessage(error.name + ": " + error.message);
      }

      socket.on("announce", data => {
        displayMessage(data.message);
      });

      socket.on("message", data => {
        displayMessage(data.author + ": " + data.message);
      });

      function displayMessage(message) {
        chatArea.innerHTML = chatArea.innerHTML + "<br />" + message;
      }

      function displaySignalMessage(message) {
        signalingArea.innerHTML = signalingArea.innerHTML + "<br />" + message;
      }

      sendMessage.addEventListener(
        "click",
        evt => {
          socket.emit("send", {
            author: myName.value,
            message: myMessage.value,
            room: ROOM
          });

          dataChannel.send(myName.value + " says " + myMessage.value);

          evt.preventDefault();
        },
        false
      );
    </script>
  </body>
</html>
